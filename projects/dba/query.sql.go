// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query.sql

package projectmodel

import (
	"context"
	"database/sql"
)

const createProject = `-- name: CreateProject :execresult
INSERT INTO projects (
  name, client, period, manager_id, markdown
) VALUES (
  ?, ?, ?, ?, ?
)
`

type CreateProjectParams struct {
	Name      string `json:"name"`
	Client    string `json:"client"`
	Period    string `json:"period"`
	ManagerID int64  `json:"manager_id"`
	Markdown  string `json:"markdown"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProject,
		arg.Name,
		arg.Client,
		arg.Period,
		arg.ManagerID,
		arg.Markdown,
	)
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProject, id)
	return err
}

const getProject = `-- name: GetProject :one
/*
  id      BIGINT  NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name    varchar(256)        NOT NULL,
  client  varchar(64)         NOT NULL,
  period  VARCHAR(32)         NOT NULL,
  manager_id BIGINT           NOT NULL DEFAULT -1,
  show_calc   INT(1)          NOT NULL DEFAULT 1,
  created_at  DATETIME        NOT NULL DEFAULT NOW(),
  updated_at  DATETIME        NOT NULL DEFAULT NOW(),
  CONSTRAINT ` + "`" + `f_manager_id_project` + "`" + `
    FOREIGN KEY (` + "`" + `manager_id` + "`" + `)
    REFERENCES ` + "`" + `users` + "`" + ` (` + "`" + `id` + "`" + `)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
*/
SELECT id, name, client, period, status, markdown, manager_id, show_calc, created_at, updated_at FROM projects
WHERE id = ? LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id int64) (*Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Client,
		&i.Period,
		&i.Status,
		&i.Markdown,
		&i.ManagerID,
		&i.ShowCalc,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listCalcProjects = `-- name: ListCalcProjects :many
SELECT id, name, client, period, status, markdown, manager_id, show_calc, created_at, updated_at FROM projects
WHERE show_calc = 1
ORDER BY client, period, name
`

func (q *Queries) ListCalcProjects(ctx context.Context) ([]*Project, error) {
	rows, err := q.db.QueryContext(ctx, listCalcProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Client,
			&i.Period,
			&i.Status,
			&i.Markdown,
			&i.ManagerID,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCalcsByManager = `-- name: ListProjectCalcsByManager :many
SELECT id, name, client, period, status, markdown, manager_id, show_calc, created_at, updated_at FROM projects
WHERE manager_id = ? AND show_calc = 1
ORDER BY client, period, name
`

func (q *Queries) ListProjectCalcsByManager(ctx context.Context, managerID int64) ([]*Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjectCalcsByManager, managerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Client,
			&i.Period,
			&i.Status,
			&i.Markdown,
			&i.ManagerID,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, client, period, status, markdown, manager_id, show_calc, created_at, updated_at FROM projects
ORDER BY client, period, name
`

func (q *Queries) ListProjects(ctx context.Context) ([]*Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Client,
			&i.Period,
			&i.Status,
			&i.Markdown,
			&i.ManagerID,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByManager = `-- name: ListProjectsByManager :many
SELECT id, name, client, period, status, markdown, manager_id, show_calc, created_at, updated_at FROM projects
WHERE manager_id = ?
ORDER BY client, period, name
`

func (q *Queries) ListProjectsByManager(ctx context.Context, managerID int64) ([]*Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsByManager, managerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Client,
			&i.Period,
			&i.Status,
			&i.Markdown,
			&i.ManagerID,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :execresult
UPDATE projects SET
  name = ?,
  client = ?,
  period = ?,
  manager_id = ?,
  markdown = ?
WHERE id = ?
`

type UpdateProjectParams struct {
	Name      string `json:"name"`
	Client    string `json:"client"`
	Period    string `json:"period"`
	ManagerID int64  `json:"manager_id"`
	Markdown  string `json:"markdown"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateProject,
		arg.Name,
		arg.Client,
		arg.Period,
		arg.ManagerID,
		arg.Markdown,
		arg.ID,
	)
}

const updateProjectStatus = `-- name: UpdateProjectStatus :execresult
UPDATE projects SET
  status = ?
WHERE id = ?
`

type UpdateProjectStatusParams struct {
	Status int32 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) UpdateProjectStatus(ctx context.Context, arg UpdateProjectStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateProjectStatus, arg.Status, arg.ID)
}
