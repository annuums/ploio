// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query.sql

package jobmodel

import (
	"context"
	"database/sql"
)

const createJob = `-- name: CreateJob :execresult
INSERT INTO jobs (
  name, period, manager_id, project_id, markdown
) VALUES (
  ?, ?, ?, ?, ?
)
`

type CreateJobParams struct {
	Name      string `json:"name"`
	Period    string `json:"period"`
	ManagerID int64  `json:"manager_id"`
	ProjectID int64  `json:"project_id"`
	Markdown  string `json:"markdown"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createJob,
		arg.Name,
		arg.Period,
		arg.ManagerID,
		arg.ProjectID,
		arg.Markdown,
	)
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs
WHERE id = ?
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const getJob = `-- name: GetJob :one
/*
  id          BIGINT            NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name        VARCHAR(256)      NOT NULL,
  period      VARCHAR(32)       NOT NULL,
  status      INT               NOT NULL DEFAULT 0,
  manager_id  BIGINT            NOT NULL DEFAULT -1,
  project_id  BIGINT            NOT NULL DEFAULT -1,
  markdown    LONGTEXT          NOT NULL DEFAULT "# EMPTY MARKDOWN",
  show_calc   INT(1)            NOT NULL DEFAULT 0,
  created_at  DATETIME          NOT NULL DEFAULT NOW(),
  updated_at  DATETIME          NOT NULL DEFAULT NOW(),
  CONSTRAINT ` + "`" + `f_manager_id_job` + "`" + `
    FOREIGN KEY (` + "`" + `manager_id` + "`" + `)
    REFERENCES ` + "`" + `users` + "`" + ` (` + "`" + `id` + "`" + `)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT ` + "`" + `f_project_id_job` + "`" + `
    FOREIGN KEY (` + "`" + `project_id` + "`" + `)
    REFERENCES ` + "`" + `projects` + "`" + ` (` + "`" + `id` + "`" + `)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
*/
SELECT id, name, period, status, manager_id, project_id, markdown, show_calc, created_at, updated_at FROM jobs
WHERE id = ? LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (*Job, error) {
	row := q.db.QueryRowContext(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Period,
		&i.Status,
		&i.ManagerID,
		&i.ProjectID,
		&i.Markdown,
		&i.ShowCalc,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listCalcJobs = `-- name: ListCalcJobs :many
SELECT id, name, period, status, manager_id, project_id, markdown, show_calc, created_at, updated_at FROM jobs
WHERE show_calc = 1
ORDER BY project_id, period, name
`

func (q *Queries) ListCalcJobs(ctx context.Context) ([]*Job, error) {
	rows, err := q.db.QueryContext(ctx, listCalcJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.ProjectID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobs = `-- name: ListJobs :many
SELECT id, name, period, status, manager_id, project_id, markdown, show_calc, created_at, updated_at FROM jobs
ORDER BY project_id, period, name
`

func (q *Queries) ListJobs(ctx context.Context) ([]*Job, error) {
	rows, err := q.db.QueryContext(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.ProjectID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByManager = `-- name: ListJobsByManager :many
SELECT id, name, period, status, manager_id, project_id, markdown, show_calc, created_at, updated_at FROM jobs
WHERE manager_id = ?
ORDER BY project_id, period, name
`

func (q *Queries) ListJobsByManager(ctx context.Context, managerID int64) ([]*Job, error) {
	rows, err := q.db.QueryContext(ctx, listJobsByManager, managerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.ProjectID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsCalcsByManager = `-- name: ListJobsCalcsByManager :many
SELECT id, name, period, status, manager_id, project_id, markdown, show_calc, created_at, updated_at FROM jobs
WHERE manager_id = ? AND show_calc = 1
ORDER BY project_id, period, name
`

func (q *Queries) ListJobsCalcsByManager(ctx context.Context, managerID int64) ([]*Job, error) {
	rows, err := q.db.QueryContext(ctx, listJobsCalcsByManager, managerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.ProjectID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :execresult
UPDATE jobs SET
  name = ?,
  period = ?,
  manager_id = ?,
  project_id = ?,
  status = ?,
  show_calc = ?,
  markdown = ?
WHERE id = ?
`

type UpdateJobParams struct {
	Name      string `json:"name"`
	Period    string `json:"period"`
	ManagerID int64  `json:"manager_id"`
	ProjectID int64  `json:"project_id"`
	Status    int32  `json:"status"`
	ShowCalc  int32  `json:"show_calc"`
	Markdown  string `json:"markdown"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateJob,
		arg.Name,
		arg.Period,
		arg.ManagerID,
		arg.ProjectID,
		arg.Status,
		arg.ShowCalc,
		arg.Markdown,
		arg.ID,
	)
}

const updateJobStatus = `-- name: UpdateJobStatus :execresult
UPDATE jobs SET
  status = ?
WHERE id = ?
`

type UpdateJobStatusParams struct {
	Status int32 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateJobStatus, arg.Status, arg.ID)
}
