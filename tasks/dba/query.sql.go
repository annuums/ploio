// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query.sql

package taskmodel

import (
	"context"
	"database/sql"
)

const createTask = `-- name: CreateTask :execresult
INSERT INTO tasks (
  name, period, manager_id, job_id, markdown
) VALUES (
  ?, ?, ?, ?, ?
)
`

type CreateTaskParams struct {
	Name      string `json:"name"`
	Period    string `json:"period"`
	ManagerID int64  `json:"manager_id"`
	JobID     int64  `json:"job_id"`
	Markdown  string `json:"markdown"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTask,
		arg.Name,
		arg.Period,
		arg.ManagerID,
		arg.JobID,
		arg.Markdown,
	)
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks
WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const getTask = `-- name: GetTask :one
/*
  id          BIGINT            NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name        VARCHAR(256)      NOT NULL,
  period      VARCHAR(32)       NOT NULL,
  manager_id  BIGINT            NOT NULL DEFAULT -1,
  job_id      BIGINT            NOT NULL DEFAULT -1,
  markdown    LONGTEXT          NOT NULL DEFAULT "# EMPTY MARKDOWN",
  created_at  DATETIME          NOT NULL DEFAULT NOW(),
  updated_at  DATETIME          NOT NULL DEFAULT NOW(),
  CONSTRAINT ` + "`" + `f_manager_id_task` + "`" + `
    FOREIGN KEY (` + "`" + `manager_id` + "`" + `)
    REFERENCES ` + "`" + `users` + "`" + ` (` + "`" + `id` + "`" + `)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT ` + "`" + `f_job_id_task` + "`" + `
    FOREIGN KEY (` + "`" + `job_id` + "`" + `)
    REFERENCES ` + "`" + `jobs` + "`" + ` (` + "`" + `id` + "`" + `)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
*/
SELECT id, name, period, status, manager_id, job_id, markdown, show_calc, created_at, updated_at FROM tasks
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, id int64) (*Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Period,
		&i.Status,
		&i.ManagerID,
		&i.JobID,
		&i.Markdown,
		&i.ShowCalc,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listCalcTasks = `-- name: ListCalcTasks :many
SELECT id, name, period, status, manager_id, job_id, markdown, show_calc, created_at, updated_at FROM tasks
WHERE show_calc = 1
ORDER BY job_id, name
`

func (q *Queries) ListCalcTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listCalcTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.JobID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCalcTasksByJob = `-- name: ListCalcTasksByJob :many
SELECT id, name, period, status, manager_id, job_id, markdown, show_calc, created_at, updated_at FROM tasks
WHERE job_id = ? AND show_calc = 1
ORDER BY name
`

func (q *Queries) ListCalcTasksByJob(ctx context.Context, jobID int64) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listCalcTasksByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.JobID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, name, period, status, manager_id, job_id, markdown, show_calc, created_at, updated_at FROM tasks
ORDER BY job_id, period, name
`

func (q *Queries) ListTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.JobID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByJob = `-- name: ListTasksByJob :many
SELECT id, name, period, status, manager_id, job_id, markdown, show_calc, created_at, updated_at FROM tasks
WHERE job_id = ?
ORDER BY period, name
`

func (q *Queries) ListTasksByJob(ctx context.Context, jobID int64) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Period,
			&i.Status,
			&i.ManagerID,
			&i.JobID,
			&i.Markdown,
			&i.ShowCalc,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :execresult
UPDATE tasks SET
  name = ?,
  period = ?,
  manager_id = ?,
  job_id = ?,
  markdown = ?
WHERE id = ?
`

type UpdateTaskParams struct {
	Name      string `json:"name"`
	Period    string `json:"period"`
	ManagerID int64  `json:"manager_id"`
	JobID     int64  `json:"job_id"`
	Markdown  string `json:"markdown"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTask,
		arg.Name,
		arg.Period,
		arg.ManagerID,
		arg.JobID,
		arg.Markdown,
		arg.ID,
	)
}

const updateTaskStatus = `-- name: UpdateTaskStatus :execresult
UPDATE tasks SET
  status = ?
WHERE id = ?
`

type UpdateTaskStatusParams struct {
	Status int32 `json:"status"`
	ID     int64 `json:"id"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTaskStatus, arg.Status, arg.ID)
}
